import atexit
import os
import re
import shutil
import sys
import tempfile
import threading
import traceback
from itertools import chain
from shutil import which
from string import ascii_letters
from subprocess import PIPE, Popen
from typing import Dict, Iterable, Optional, Tuple

import gdb
from prompt_toolkit import PromptSession, print_formatted_text
from prompt_toolkit.application import run_in_terminal
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
from prompt_toolkit.completion import Completer, Completion
from prompt_toolkit.document import Document
from prompt_toolkit.formatted_text import ANSI, FormattedText
from prompt_toolkit.history import FileHistory, InMemoryHistory
from prompt_toolkit.key_binding import KeyPressEvent
from prompt_toolkit.output import create_output
from prompt_toolkit.shortcuts import CompleteStyle

# global variables
HAS_FZF = which("fzf") is not None
HISTORY_FILENAME = ".gdb_history"
# This sucks, but there's not a GDB API for checking dont-repeat now.
# I just collect some common used commands which should not be repeated.
# If you have some user-define function, add your command into the list manually.
# If you found a command should/shouldn't in this list, please let me know on the issue page, thanks!
DONT_REPEAT = {
    # original GDB
    "attach",
    "run",
    "r",
    "detach",
    "help",
    "complete",
    "quit",
    "q",
    # for GEF
    "theme",
    "canary",
    "functions",
    "gef",
    "tmux-setup",
}

FZF_RUN_CMD = (
    "fzf",
    "--select-1",
    "--exit-0",
    "--tiebreak=index",
    "--no-multi",
    "--height=40%",
    "--layout=reverse",
)

FZF_PRVIEW_WINDOW_ARGS = (
    "--preview-window",
    "right:55%:wrap",
)

try:
    from geprc import BINDINGS
    from geprc import DONT_REPEAT as USER_DONT_REPEAT

    DONT_REPEAT = DONT_REPEAT.union(USER_DONT_REPEAT)
except ImportError:
    from prompt_toolkit.key_binding import KeyBindings

    BINDINGS = KeyBindings()


# function for logging
def print_info(s):
    print_formatted_text(FormattedText([("#00FFFF", s)]), file=sys.__stdout__)


def print_warning(s):
    print_formatted_text(FormattedText([("#FFCC00", s)]), file=sys.__stdout__)


def get_gdb_completes(query: str) -> Iterable[str]:
    completions_limit = gdb.parameter("max-completions")
    if completions_limit == -1:
        completions_limit = 0xFFFFFFFF
    if completions_limit == 0:
        return
    if query.strip() and query[-1].isspace():
        # fuzzing all possible commands if the text before cursor endswith space
        all_completions = []
        for c in ascii_letters + "_-":
            if completions_limit <= 0:
                break
            completions = gdb.execute(
                "complete %s" % query + c, to_string=True
            ).splitlines()[:completions_limit]
            all_completions = chain(all_completions, completions)
            completions_limit -= len(completions)
    else:
        all_completions = gdb.execute(
            "complete %s" % query, to_string=True
        ).splitlines()[:completions_limit]
        all_completions = iter(all_completions)

    return all_completions


def safe_get_help_docs(command: str) -> Optional[str]:
    """
    A wrapper for gdb.execute('help <command>', to_string=True), but return None if gdb raise an exception.
    """
    try:
        return gdb.execute("help %s" % command, to_string=True).strip()
    except gdb.error:
        return None


def should_get_help_docs(completion: str) -> bool:
    """
    Check if we need to get help docs for another completion that generated by same command.
    """
    if " " not in completion.strip():
        return True
    parent_command, _ = completion.rsplit(maxsplit=1)
    return safe_get_help_docs(parent_command) != safe_get_help_docs(completion)


def get_gdb_completion_and_status(query: str) -> Tuple[Iterable[str], bool]:
    all_completions = get_gdb_completes(query)
    # peek the first completion
    first_completion = next(all_completions, None)
    should_get_all_help_docs = False
    if first_completion:
        # restore the iterator
        all_completions = chain([first_completion], all_completions)
        should_get_all_help_docs = should_get_help_docs(first_completion)
    return all_completions, should_get_all_help_docs, first_completion is None


def create_fzf_process(query, preview: str = "") -> Popen:
    """
    Create a fzf process with given query and preview command.
    """
    if not HAS_FZF:
        raise ValueError("fzf is not installed")
    if query.startswith("!"):
        # ! in the beginning of query means we want to run the command directly for fzf
        query = "^" + query
    cmd = FZF_RUN_CMD + ("--query", query)
    if preview:
        cmd += FZF_PRVIEW_WINDOW_ARGS
        cmd += ("--preview", preview)
    return Popen(cmd, stdin=PIPE, stdout=PIPE, text=True)


def create_preview_fifos():
    """
    Create a temporary directory and two FIFOs in it.

    This is modified from:
    https://github.com/infokiller/config-public/blob/652b4638a0a0ffed9743fa9e0ad2a8d4e4e90572/.config/ipython/profile_default/startup/ext/fzf_history.py#L128
    """
    fifo_dir = tempfile.mkdtemp(prefix="gep_tab_fzf_")
    fifo_input_path = os.path.join(fifo_dir, "input")
    fifo_output_path = os.path.join(fifo_dir, "output")
    os.mkfifo(fifo_input_path)
    os.mkfifo(fifo_output_path)
    atexit.register(shutil.rmtree, fifo_dir)
    return fifo_input_path, fifo_output_path


def fzf_reverse_search(event: KeyPressEvent):
    """Reverse search history with fzf."""

    def _fzf_reverse_search():
        global HISTORY_FILENAME
        if not os.path.exists(HISTORY_FILENAME):
            # just create an empty file
            with open(HISTORY_FILENAME, "w"):
                pass
        p = create_fzf_process(event.app.current_buffer.document.text_before_cursor)
        with open(HISTORY_FILENAME) as f:
            visited = set()
            # Reverse the history, and only keep the youngest and unique one
            for line in f.read().strip().split("\n")[::-1]:
                if line and not line in visited:
                    visited.add(line)
                    p.stdin.write(line + "\n")
        stdout, _ = p.communicate()
        if stdout:
            event.app.current_buffer.document = Document()  # clear buffer
            event.app.current_buffer.insert_text(stdout.strip())

    run_in_terminal(_fzf_reverse_search)


def fzf_tab_autocomplete(event: KeyPressEvent):
    """
    Tab autocomplete with fzf.
    """

    def _fzf_tab_autocomplete():
        text_before_cursor = event.app.current_buffer.document.text_before_cursor
        (
            all_completions,
            should_get_all_help_docs,
            is_empty,
        ) = get_gdb_completion_and_status(text_before_cursor)
        if is_empty:
            return
        query = re.split(r"\W+", text_before_cursor)[-1]
        p = create_fzf_process(
            query, FZF_PRVIEW_CMD if should_get_all_help_docs else None
        )
        completion_help_docs = {}
        cursor_idx_in_completion = len(text_before_cursor.lstrip())
        for i, completion in enumerate(all_completions):
            p.stdin.write(query + completion[cursor_idx_in_completion:] + "\n")
            if should_get_all_help_docs:
                completion_help_docs[i] = safe_get_help_docs(completion)
        t = FzfTabCompletePreviewThread(
            FIFO_INPUT_PATH, FIFO_OUTPUT_PATH, completion_help_docs
        )
        t.start()
        stdout, _ = p.communicate()
        t.stop()
        if stdout:
            # append the rest of the completion after the query
            query_len = len(query)
            event.app.current_buffer.insert_text(stdout[query_len:].strip())

    run_in_terminal(_fzf_tab_autocomplete)


class FzfTabCompletePreviewThread(threading.Thread):
    """
    A thread for previewing help docs of selected completion with fzf.

    This is modified from:
    https://github.com/infokiller/config-public/blob/master/.config/ipython/profile_default/startup/ext/fzf_history.py#L72
    """

    def __init__(
        self,
        fifo_input_path: str,
        fifo_output_path: str,
        completion_help_docs: Dict,
        **kwargs
    ):
        super().__init__(**kwargs)
        self.fifo_input_path = fifo_input_path
        self.fifo_output_path = fifo_output_path
        self.completion_help_docs = completion_help_docs
        self.is_done = threading.Event()

    def run(self) -> None:
        while not self.is_done.is_set():
            with open(self.fifo_input_path, encoding="utf-8") as fifo_input:
                while not self.is_done.is_set():
                    data = fifo_input.read()
                    if len(data) == 0:
                        break
                    with open(
                        self.fifo_output_path, "w", encoding="utf-8"
                    ) as fifo_output:
                        try:
                            idx = int(data)
                        except ValueError:
                            continue
                        help_doc = self.completion_help_docs.get(idx)
                        if help_doc is not None:
                            fifo_output.write(help_doc)

    def stop(self):
        self.is_done.set()
        with open(self.fifo_input_path, "w", encoding="utf-8") as f:
            f.close()
        self.join()


class UserParamater(gdb.Parameter):
    gep_loaded = False

    def __init__(
        self,
        name,
        default_value,
        set_show_doc,
        parameter_class,
        help_doc="",
        enum_sequence=None,
    ):
        self.set_show_doc = set_show_doc
        self.set_doc = "Set %s." % self.set_show_doc
        self.show_doc = "Show %s." % self.set_show_doc
        self.__doc__ = help_doc.strip() or None
        if enum_sequence:
            super().__init__(name, gdb.COMMAND_NONE, parameter_class, enum_sequence)
        else:
            super().__init__(name, gdb.COMMAND_NONE, parameter_class)
        self.value = default_value

    def get_set_string(self):
        if not self.gep_loaded:
            return ""
        svalue = self.value
        # TODO: Support other type when needed
        if isinstance(svalue, bool):
            svalue = "on" if svalue else "off"
        return "Set %s to %r." % (self.set_show_doc, svalue)

    def get_show_string(self, svalue):
        if not self.gep_loaded:
            return ""
        return "%s is %r." % (self.set_show_doc.capitalize(), svalue)


ctrl_c_quit = UserParamater(
    "ctrl-c-quit", False, "whether to use ctrl-c to exit the gdb", gdb.PARAM_BOOLEAN
)

single_column_tab_complete = UserParamater(
    "single-column-tab-complete",
    True,
    "whether to use single column for tab completion",
    gdb.PARAM_BOOLEAN,
)

if HAS_FZF:
    # key binding for fzf history search
    BINDINGS.add("c-r")(fzf_reverse_search)
    # key binding for fzf tab completion
    FIFO_INPUT_PATH, FIFO_OUTPUT_PATH = create_preview_fifos()
    FZF_PRVIEW_CMD = "echo {n} > %s\ncat %s" % (FIFO_INPUT_PATH, FIFO_OUTPUT_PATH)
    BINDINGS.add("c-i")(fzf_tab_autocomplete)
else:
    print_warning("Install fzf for better experience with GEP")


class GDBHistory(FileHistory):
    """
    Manage your GDB History
    """

    def __init__(self, filename, ignore_duplicates=False):
        self.ignore_duplicates = ignore_duplicates
        super().__init__(filename=filename)

    def load_history_strings(self):
        temp_strings = []

        if os.path.exists(self.filename):
            with open(self.filename, "rb") as f:
                for line in f:
                    line = line.decode("utf-8")
                    string = line.strip()
                    temp_strings.append(string)

        strings = []
        for string in reversed(temp_strings):
            if self.ignore_duplicates and string in strings:
                continue
            if string:
                strings.append(string)
        return strings

    def store_string(self, string):
        with open(self.filename, "ab") as f:
            f.write(string.strip().encode() + b"\n")


class GDBCompleter(Completer):
    """
    Completer of GDB
    """

    def __init__(self):
        super().__init__()

    def get_completions(self, document, complete_event):
        text_before_cursor = document.text_before_cursor
        cursor_idx_in_completion = len(text_before_cursor.lstrip())
        (
            all_completions,
            should_get_all_help_docs,
            is_empty,
        ) = get_gdb_completion_and_status(text_before_cursor)
        if is_empty:
            return

        for completion in all_completions:
            display_meta = (
                None
                if not should_get_all_help_docs
                else safe_get_help_docs(completion) or None
            )
            # remove some prefix of raw completion
            completion = completion[cursor_idx_in_completion:]
            # display readable completion based on the text before cursor
            display = re.split(r"\W+", text_before_cursor)[-1] + completion
            yield Completion(completion, display=display, display_meta=display_meta)


class GDBConsoleWrapper:
    """
    Wrapper of original GDB console
    """

    def __init__(self):
        old_prompt_hook = gdb.prompt_hook

        def prompt_until_exit(current_prompt):
            gdb.prompt_hook = old_prompt_hook  # retrieve old prompt hook
            print_info("GEP is running now!")
            UserParamater.gep_loaded = True
            history_on = gdb.parameter("history save")
            if history_on:
                global HISTORY_FILENAME
                HISTORY_FILENAME = gdb.parameter("history filename")
                is_ignore_duplicates = -1 == gdb.parameter("history remove-duplicates")
                gdb_history = GDBHistory(
                    HISTORY_FILENAME, ignore_duplicates=is_ignore_duplicates
                )
            else:
                print_warning("`set history save on` for better experience with GEP")
                gdb_history = InMemoryHistory()
            session = PromptSession(
                history=gdb_history,
                enable_history_search=True,
                auto_suggest=AutoSuggestFromHistory(),
                completer=GDBCompleter() if not HAS_FZF else None,
                complete_style=CompleteStyle.COLUMN
                if single_column_tab_complete.value
                else CompleteStyle.MULTI_COLUMN,
                complete_while_typing=False,
                key_bindings=BINDINGS,
                output=create_output(stdout=sys.__stdout__),
            )
            while True:
                try:
                    # emulate the original prompt
                    prompt_string = (
                        gdb.prompt_hook(current_prompt) if gdb.prompt_hook else None
                    )
                    if prompt_string is None:  # prompt string is set by gdb command
                        prompt_string = gdb.parameter("prompt")
                    prompt_string = prompt_string.replace("\001", "").replace(
                        "\002", ""
                    )  # fix for ANSI prompt
                    gdb_cmd = session.prompt(ANSI(prompt_string))
                    if not gdb_cmd.strip():
                        gdb_cmd_list = gdb_history.get_strings()
                        if gdb_cmd_list:
                            previous_gdb_cmd = gdb_cmd_list[-1]
                            if (
                                previous_gdb_cmd.split()
                                and previous_gdb_cmd.split()[0] not in DONT_REPEAT
                            ):
                                gdb_cmd = previous_gdb_cmd
                    gdb.execute(gdb_cmd, from_tty=True)
                except gdb.error as e:
                    print(e)
                except KeyboardInterrupt:
                    if ctrl_c_quit.value:
                        gdb.execute("quit")
                except EOFError:
                    gdb.execute("quit")
                except Exception as e:
                    print(e)
                    traceback.print_tb(e.__traceback__)

        gdb.prompt_hook = prompt_until_exit


GDBConsoleWrapper()


class UpdateGEPCommand(gdb.Command):
    """
    Update GEP to the latest version
    """

    def __init__(self):
        super(UpdateGEPCommand, self).__init__("gep-update", gdb.COMMAND_NONE)

    def invoke(self, arg, from_tty):
        print_info("Updating GEP...")
        gep_filename = os.path.expanduser("~/GEP/.gdbinit-gep.py")
        if not os.path.exists(gep_filename):
            print_warning("GEP is not installed at %s, update aborted" % gep_filename)
            return
        with open(gep_filename, "r") as f:
            try:
                import urllib.request

                content = f.read()
                remote_content = urllib.request.urlopen(
                    "https://raw.githubusercontent.com/lebr0nli/GEP/main/gdbinit-gep.py"
                ).read()
            except Exception as e:
                print(e)
                print_warning("Failed to download GEP from Github")
                return
            if content == remote_content.decode("utf-8"):
                print_info("GEP is already the latest version.")
                return
        with open(gep_filename, "w") as f:
            f.write(remote_content.decode("utf-8"))
        print_info("GEP is updated to the latest version.")


UpdateGEPCommand()

import atexit
import os
import re
import shutil
import sys
import tempfile
import threading
import traceback
from itertools import chain
from shutil import which
from string import ascii_letters
from subprocess import PIPE
from subprocess import Popen
from typing import Dict
from typing import Iterable
from typing import Optional
from typing import Tuple

import gdb
from prompt_toolkit import PromptSession
from prompt_toolkit import print_formatted_text
from prompt_toolkit.application import run_in_terminal
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
from prompt_toolkit.completion import Completer
from prompt_toolkit.completion import Completion
from prompt_toolkit.document import Document
from prompt_toolkit.formatted_text import ANSI
from prompt_toolkit.formatted_text import FormattedText
from prompt_toolkit.history import FileHistory
from prompt_toolkit.history import InMemoryHistory
from prompt_toolkit.key_binding import KeyPressEvent
from prompt_toolkit.output import create_output
from prompt_toolkit.shortcuts import CompleteStyle

# global variables
HAS_FZF = which("fzf") is not None
HISTORY_FILENAME = ".gdb_history"
# This sucks, but there's not a GDB API for checking dont-repeat now.
# I just collect some common used commands which should not be repeated.
# If you have some user-define function, add your command into the list manually.
# If you found a command should/shouldn't in this list, please let me know on the issue page, thanks!
DONT_REPEAT = {
    # original GDB
    "attach",
    "run",
    "r",
    "detach",
    "help",
    "complete",
    "quit",
    "q",
    # for GEF
    "theme",
    "canary",
    "functions",
    "gef",
    "tmux-setup",
}

FZF_RUN_CMD = (
    "fzf",
    "--select-1",
    "--exit-0",
    "--tiebreak=index",
    "--no-multi",
    "--height=40%",
    "--layout=reverse",
)

FZF_PRVIEW_WINDOW_ARGS = (
    "--preview-window",
    "right:55%:wrap",
)

try:
    directory, file = os.path.split(__file__)
    directory = os.path.expanduser(directory)
    directory = os.path.abspath(directory)
    sys.path.append(directory)
    from geprc import BINDINGS
    from geprc import DONT_REPEAT as USER_DONT_REPEAT

    DONT_REPEAT = DONT_REPEAT.union(USER_DONT_REPEAT)
except ImportError:
    from prompt_toolkit.key_binding import KeyBindings

    BINDINGS = KeyBindings()


# function for logging
def print_info(s):
    print_formatted_text(FormattedText([("#00FFFF", s)]), file=sys.__stdout__)


def print_warning(s):
    print_formatted_text(FormattedText([("#FFCC00", s)]), file=sys.__stdout__)


def get_gdb_completes(query: str) -> Iterable[str]:
    completions_limit = gdb.parameter("max-completions")
    if completions_limit == -1:
        completions_limit = 0xFFFFFFFF
    if completions_limit == 0:
        return
    if query.strip() and query[-1].isspace():
        # fuzzing all possible commands if the text before cursor endswith space
        all_completions = []
        for c in ascii_letters + "_-":
            if completions_limit <= 0:
                break
            completions = gdb.execute("complete %s" % query + c, to_string=True).splitlines()[
                :completions_limit
            ]
            all_completions = chain(all_completions, completions)
            completions_limit -= len(completions)
    else:
        all_completions = gdb.execute("complete %s" % query, to_string=True).splitlines()[
            :completions_limit
        ]
        all_completions = iter(all_completions)

    return all_completions


def safe_get_help_docs(command: str) -> Optional[str]:
    """
    A wrapper for gdb.execute('help <command>', to_string=True), but return None if gdb raise an exception.
    """
    try:
        return gdb.execute("help %s" % command, to_string=True).strip()
    except gdb.error:
        return None


def should_get_help_docs(completion: str) -> bool:
    """
    Check if we need to get help docs for another completion that generated by same command.
    """
    if " " not in completion.strip():
        return True
    parent_command, _ = completion.rsplit(maxsplit=1)
    return safe_get_help_docs(parent_command) != safe_get_help_docs(completion)


def get_gdb_completion_and_status(query: str) -> Tuple[Iterable[str], bool]:
    all_completions = get_gdb_completes(query)
    # peek the first completion
    first_completion = next(all_completions, None)
    should_get_all_help_docs = False
    if first_completion:
        # restore the iterator
        all_completions = chain([first_completion], all_completions)
        should_get_all_help_docs = should_get_help_docs(first_completion)
    return all_completions, should_get_all_help_docs, first_completion is None


def create_fzf_process(query, preview: str = "") -> Popen:
    """
    Create a fzf process with given query and preview command.
    """
    if not HAS_FZF:
        raise ValueError("fzf is not installed")
    if query.startswith("!"):
        # ! in the beginning of query means we want to run the command directly for fzf
        query = "^" + query
    cmd = FZF_RUN_CMD + ("--query", query)
    if preview:
        cmd += FZF_PRVIEW_WINDOW_ARGS
        cmd += ("--preview", preview)
    return Popen(cmd, stdin=PIPE, stdout=PIPE, text=True)


def create_preview_fifos():
    """
    Create a temporary directory and two FIFOs in it.

    This is modified from:
    https://github.com/infokiller/config-public/blob/652b4638a0a0ffed9743fa9e0ad2a8d4e4e90572/.config/ipython/profile_default/startup/ext/fzf_history.py#L128
    """
    fifo_dir = tempfile.mkdtemp(prefix="gep_tab_fzf_")
    fifo_input_path = os.path.join(fifo_dir, "input")
    fifo_output_path = os.path.join(fifo_dir, "output")
    os.mkfifo(fifo_input_path)
    os.mkfifo(fifo_output_path)
    atexit.register(shutil.rmtree, fifo_dir)
    return fifo_input_path, fifo_output_path


def fzf_reverse_search(event: KeyPressEvent):
    """Reverse search history with fzf."""

    def _fzf_reverse_search():
        global HISTORY_FILENAME
        if not os.path.exists(HISTORY_FILENAME):
            # just create an empty file
            with open(HISTORY_FILENAME, "w"):
                pass
        p = create_fzf_process(event.app.current_buffer.document.text_before_cursor)
        with open(HISTORY_FILENAME) as f:
            visited = set()
            # Reverse the history, and only keep the youngest and unique one
            for line in f.read().strip().split("\n")[::-1]:
                if line and line not in visited:
                    visited.add(line)
                    p.stdin.write(line + "\n")
        stdout, _ = p.communicate()
        if stdout:
            event.app.current_buffer.document = Document()  # clear buffer
            event.app.current_buffer.insert_text(stdout.strip())

    run_in_terminal(_fzf_reverse_search)


def fzf_tab_autocomplete(event: KeyPressEvent):
    """
    Tab autocomplete with fzf.
    """

    def _fzf_tab_autocomplete():
        text_before_cursor = event.app.current_buffer.document.text_before_cursor
        (
            all_completions,
            should_get_all_help_docs,
            is_empty,
        ) = get_gdb_completion_and_status(text_before_cursor)
        if is_empty:
            return
        query = re.split(r"\W+", text_before_cursor)[-1]
        p = create_fzf_process(query, FZF_PRVIEW_CMD if should_get_all_help_docs else None)
        completion_help_docs = {}
        cursor_idx_in_completion = len(text_before_cursor.lstrip())
        for i, completion in enumerate(all_completions):
            p.stdin.write(query + completion[cursor_idx_in_completion:] + "\n")
            if should_get_all_help_docs:
                completion_help_docs[i] = safe_get_help_docs(completion)
        t = FzfTabCompletePreviewThread(FIFO_INPUT_PATH, FIFO_OUTPUT_PATH, completion_help_docs)
        t.start()
        stdout, _ = p.communicate()
        t.stop()
        if stdout:
            # append the rest of the completion after the query
            query_len = len(query)
            event.app.current_buffer.insert_text(stdout[query_len:].strip())

    run_in_terminal(_fzf_tab_autocomplete)


class FzfTabCompletePreviewThread(threading.Thread):
    """
    A thread for previewing help docs of selected completion with fzf.

    This is modified from:
    https://github.com/infokiller/config-public/blob/master/.config/ipython/profile_default/startup/ext/fzf_history.py#L72
    """

    def __init__(
        self, fifo_input_path: str, fifo_output_path: str, completion_help_docs: Dict, **kwargs
    ):
        super().__init__(**kwargs)
        self.fifo_input_path = fifo_input_path
        self.fifo_output_path = fifo_output_path
        self.completion_help_docs = completion_help_docs
        self.is_done = threading.Event()

    def run(self) -> None:
        while not self.is_done.is_set():
            with open(self.fifo_input_path, encoding="utf-8") as fifo_input:
                while not self.is_done.is_set():
                    data = fifo_input.read()
                    if len(data) == 0:
                        break
                    with open(self.fifo_output_path, "w", encoding="utf-8") as fifo_output:
                        try:
                            idx = int(data)
                        except ValueError:
                            continue
                        help_doc = self.completion_help_docs.get(idx)
                        if help_doc is not None:
                            fifo_output.write(help_doc)

    def stop(self):
        self.is_done.set()
        with open(self.fifo_input_path, "w", encoding="utf-8") as f:
            f.close()
        self.join()


class UserParamater(gdb.Parameter):
    gep_loaded = False

    def __init__(
        self,
        name,
        default_value,
        set_show_doc,
        parameter_class,
        help_doc="",
        enum_sequence=None,
    ):
        self.set_show_doc = set_show_doc
        self.set_doc = "Set %s." % self.set_show_doc
        self.show_doc = "Show %s." % self.set_show_doc
        self.__doc__ = help_doc.strip() or None
        if enum_sequence:
            super().__init__(name, gdb.COMMAND_NONE, parameter_class, enum_sequence)
        else:
            super().__init__(name, gdb.COMMAND_NONE, parameter_class)
        self.value = default_value

    def get_set_string(self):
        if not self.gep_loaded:
            return ""
        svalue = self.value
        # TODO: Support other type when needed
        if isinstance(svalue, bool):
            svalue = "on" if svalue else "off"
        return "Set %s to %r." % (self.set_show_doc, svalue)

    def get_show_string(self, svalue):
        if not self.gep_loaded:
            return ""
        return "%s is %r." % (self.set_show_doc.capitalize(), svalue)


ctrl_c_quit = UserParamater(
    "ctrl-c-quit", False, "whether to use ctrl-c to exit the gdb", gdb.PARAM_BOOLEAN
)

single_column_tab_complete = UserParamater(
    "single-column-tab-complete",
    True,
    "whether to use single column for tab completion",
    gdb.PARAM_BOOLEAN,
)

if HAS_FZF:
    # key binding for fzf history search
    BINDINGS.add("c-r")(fzf_reverse_search)
    # key binding for fzf tab completion
    FIFO_INPUT_PATH, FIFO_OUTPUT_PATH = create_preview_fifos()
    FZF_PRVIEW_CMD = "echo {n} > %s\ncat %s" % (FIFO_INPUT_PATH, FIFO_OUTPUT_PATH)
    BINDINGS.add("c-i")(fzf_tab_autocomplete)
else:
    print_warning("Install fzf for better experience with GEP")


class GDBHistory(FileHistory):
    """
    Manage your GDB History
    """

    def __init__(self, filename, ignore_duplicates=False):
        self.ignore_duplicates = ignore_duplicates
        super().__init__(filename=filename)

    def load_history_strings(self):
        temp_strings = []

        if os.path.exists(self.filename):
            with open(self.filename, "rb") as f:
                for line in f:
                    line = line.decode("utf-8")
                    string = line.strip()
                    temp_strings.append(string)

        strings = []
        for string in reversed(temp_strings):
            if self.ignore_duplicates and string in strings:
                continue
            if string:
                strings.append(string)
        return strings

    def store_string(self, string):
        with open(self.filename, "ab") as f:
            f.write(string.strip().encode() + b"\n")


class GDBCompleter(Completer):
    """
    Completer of GDB
    """

    def __init__(self):
        super().__init__()

    def get_completions(self, document, complete_event):
        text_before_cursor = document.text_before_cursor
        cursor_idx_in_completion = len(text_before_cursor.lstrip())
        (
            all_completions,
            should_get_all_help_docs,
            is_empty,
        ) = get_gdb_completion_and_status(text_before_cursor)
        if is_empty:
            return

        for completion in all_completions:
            display_meta = (
                None if not should_get_all_help_docs else safe_get_help_docs(completion) or None
            )
            # remove some prefix of raw completion
            completion = completion[cursor_idx_in_completion:]
            # display readable completion based on the text before cursor
            display = re.split(r"\W+", text_before_cursor)[-1] + completion
            yield Completion(completion, display=display, display_meta=display_meta)


class UpdateGEPCommand(gdb.Command):
    """
    Update GEP to the latest version
    """

    def __init__(self):
        # we need save __file__ because somehow when gdb invoke this command, somehow __file__ will be not defined
        self.__gep_location = __file__
        super(UpdateGEPCommand, self).__init__("gep-update", gdb.COMMAND_NONE)

    def invoke(self, arg, from_tty):
        print_info("Updating GEP...")
        try:
            import urllib.request

            remote_content = urllib.request.urlopen(
                "https://raw.githubusercontent.com/lebr0nli/GEP/main/gdbinit-gep.py"
            ).read()
        except Exception as e:
            print(e)
            print_warning("Failed to download GEP from Github")
            return
        with open(self.__gep_location, "r") as f:
            content = f.read()
        if content == remote_content.decode("utf-8"):
            print_info("GEP is already the latest version.")
            return
        with open(self.__gep_location, "w") as f:
            f.write(remote_content.decode("utf-8"))
        print_info("GEP at %s is updated to the latest version." % self.__gep_location)
        print_info("Please restart GDB to use the latest version of GEP.")
        print_warning(
            "You may need to check https://github.com/lebr0nli/GEP for more information about the new version."
        )


UpdateGEPCommand()


def gep_prompt(current_prompt: str) -> None:
    print_info("GEP is running now!")
    UserParamater.gep_loaded = True
    history_on = gdb.parameter("history save")
    if history_on:
        global HISTORY_FILENAME
        HISTORY_FILENAME = gdb.parameter("history filename")
        is_ignore_duplicates = -1 == gdb.parameter("history remove-duplicates")
        gdb_history = GDBHistory(HISTORY_FILENAME, ignore_duplicates=is_ignore_duplicates)
    else:
        print_warning("`set history save on` for better experience with GEP")
        gdb_history = InMemoryHistory()
    session = PromptSession(
        history=gdb_history,
        enable_history_search=True,
        auto_suggest=AutoSuggestFromHistory(),
        completer=GDBCompleter() if not HAS_FZF else None,
        complete_style=CompleteStyle.COLUMN
        if single_column_tab_complete.value
        else CompleteStyle.MULTI_COLUMN,
        complete_while_typing=False,
        key_bindings=BINDINGS,
        output=create_output(stdout=sys.__stdout__),
    )
    while True:
        try:
            # emulate the original prompt
            prompt_string = gdb.prompt_hook(current_prompt) if gdb.prompt_hook else None
            if prompt_string is None:  # prompt string is set by gdb command
                prompt_string = gdb.parameter("prompt")
            prompt_string = prompt_string.replace("\001", "").replace(
                "\002", ""
            )  # fix for ANSI prompt
            gdb_cmd = session.prompt(ANSI(prompt_string))
            if not gdb_cmd.strip():
                gdb_cmd_list = gdb_history.get_strings()
                if gdb_cmd_list:
                    previous_gdb_cmd = gdb_cmd_list[-1]
                    if previous_gdb_cmd.split() and previous_gdb_cmd.split()[0] not in DONT_REPEAT:
                        gdb_cmd = previous_gdb_cmd
            gdb.execute(gdb_cmd, from_tty=True)
        except gdb.error as e:
            print(e)
        except KeyboardInterrupt:
            if ctrl_c_quit.value:
                gdb.execute("quit")
        except EOFError:
            gdb.execute("quit")
        except Exception as e:
            print(e)
            traceback.print_tb(e.__traceback__)


def hijack_prompt() -> None:
    """
    Hijack the original prompt and use GEP prompt
    """
    original_prompt = gdb.prompt_hook

    def hijacked_prompt(current_prompt: str) -> None:
        gdb.prompt_hook = original_prompt  # retrieve old prompt hook
        gep_prompt(current_prompt)  # pass the current_prompt to gep_prompt

    gdb.prompt_hook = hijacked_prompt


def main() -> None:
    # source the gdbinit-gep config in the same directory
    gep_path = os.path.dirname(os.path.realpath(__file__))
    gdb.execute("source %s" % os.path.join(gep_path, "gdbinit-gep"))

    # Hijack the prompt of GDB to use our own prompt
    hijack_prompt()


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        traceback.print_tb(e.__traceback__)
        print_warning(
            "Something went wrong when running GEP, please report an issue on https://github.com/lebr0nli/GEP/issues with the traceback above, thanks!"
        )
